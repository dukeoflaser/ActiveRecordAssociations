{
  "name": "ActiveRecord Associations",
  "tagline": "A study of ActiveRecord's associations and their generated methods.",
  "body": "## ActiveRecord Associations\r\nA study of ActiveRecord's Associations and their generated methods.\r\n\r\n#####Questions: What methods are generated for each association type? What is the required database column in the matching table? How do the args passed to the `initialize` method affect the situation?\r\n\r\nWe'll experiment with four models: Game, World, Character, and PowerUp.\r\n\r\nA World `has_many` characters and powerups. We're looking for the following behaviour:\r\n - `mushroom_kingdom.characters =>[...]`\r\n - `mushroom_kingdom.power_ups => [...]`\r\n \r\nCharacters and Powerups both `belong_to` a World.\r\n - `mario.world => #<World ...>`\r\n - `fire_flower.world => #<World ...>`\r\n\r\nA Character `has_many` powerups available `through` the world. \r\n - `mario.power_ups => [...]`\r\n\r\nA Powerup `belongs_to` _many_ characters. \r\n - `fire_flower.characters => [...]`\r\n\r\nAdditionally, a Game has many characters but a character also has many games.\r\n - `mario.games => [...]`\r\n - `game.characters => [...]`\r\n \r\n##Control\r\nFirst we need a control model to compare our results against. This will be a blank class that inherits from ActiveRecord. The only column it will have will be its automatically generated `id` column.\r\n```ruby\r\nclass Blank < ActiveRecord::Base\r\nend\r\n\r\nclass CreateBlanksTable < ActiveRecord::Migration\r\n  def change\r\n    create_table :blanks do |t|\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n```ruby\r\ncontrol = Blank.new\r\n=> #<Blank id: nil>\r\ncontrol_methods = control.methods.map {|m| m.to_s}.sort!\r\ncontrol_class_methods = Blank.methods.map {|m| m.to_s}.sort!\r\n```\r\nThe list of control methods can be found [here](https://github.com/MooseBoost/ActiveRecordAssociations/blob/master/control_instance_methods.md \"Instance Methods\") and [here](https://github.com/MooseBoost/ActiveRecordAssociations/blob/master/control_class_methods.md \"Class Methods\").\r\n\r\n##World\r\n```ruby\r\nclass World < ActiveRecord::Base\r\n  has_many :characters\r\nend\r\n```\r\n\r\nCreate a corresponding table with a column for the name of the world.\r\nNote that the _plural_ version of the class is used for the table.\r\n```ruby\r\nclass CreateWorldTable < ActiveRecord::Migration\r\n  def change\r\n    create_table :worlds do |t|\r\n      t.string :name\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nMigrate the change over to the database.\r\n```ruby\r\nrake db:migrate\r\n```\r\n\r\n`db/schema.rb` now has the following:\r\n```ruby\r\nActiveRecord::Schema.define(version: 20160405222201) do\r\n\r\n  create_table \"worlds\", force: :cascade do |t|\r\n    t.string \"name\"\r\n  end\r\n\r\nend\r\n```\r\n\r\nLet's now create a world that has no name. It will be a simple instance, with no attributes.\r\n```ruby\r\n>> the_world = World.create\r\nD, [2016-04-05T22:33:05.639088 #3388] DEBUG -- :    (0.2ms)  begin transaction\r\nD, [2016-04-05T22:33:05.644635 #3388] DEBUG -- :   SQL (0.5ms)  INSERT INTO \"worlds\" DEFAULT VALUES\r\nD, [2016-04-05T22:33:05.657346 #3388] DEBUG -- :    (12.0ms)  commit transaction\r\n=> #<World id: 1, name: nil>\r\n```\r\n\r\nWe are now ready to make our comparisons.\r\n\r\n###A _World_ that `has_many` _characters_\r\nNote: The list of methods was created like this:\r\n```ruby\r\n>> world_methods = the_world.methods.map {|m| m.to_s}.sort!\r\n>> (world_methods - control_methods).each {|m| puts m}\r\n\r\n>> world_class_methods = World.methods.map {|m| m.to_s}.sort!\r\n>> (world_class_methods - control_class_methods).each {|m| puts m}\r\n```\r\n\r\nAgain, here is our model and its table.\r\n```ruby\r\nclass World < ActiveRecord::Base\r\n  has_many :characters\r\nend\r\n```\r\n```ruby\r\nclass CreateWorldTable < ActiveRecord::Migration\r\n  def change\r\n    create_table :worlds do |t|\r\n      t.string :name\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#####Generated `has_many` Methods\r\nFrom `has_many(:characters)` | From DB column :name | Class Methods\r\n--- | --- | ---\r\nafter_add_for_characters | name | after_add_for_characters\r\nafter_add_for_characters= | name= | after_add_for_characters=\r\nafter_add_for_characters? | name? | after_add_for_characters?\r\nafter_remove_for_characters | name_before_type_cast | after_remove_for_characters\r\nafter_remove_for_characters= | name_came_from_user? | after_remove_for_characters=\r\nafter_remove_for_characters? | name_change | after_remove_for_characters?\r\nautosave_associated_records_for_characters | name_changed? |\r\nbefore_add_for_characters | name_was | before_add_for_characters\r\nbefore_add_for_characters= | name_will_change! | before_add_for_characters=\r\nbefore_add_for_characters? | reset_name! | before_add_for_characters?\r\nbefore_remove_for_characters | restore_name! | before_remove_for_characters\r\nbefore_remove_for_characters= | | before_remove_for_characters=\r\nbefore_remove_for_characters? | | before_remove_for_characters?\r\ncharacter_ids | |\r\ncharacter_ids= | |\r\ncharacters | |\r\ncharacters= | |\r\nvalidate_associated_records_for_characters | |\r\n\r\nAs you can see, ActiveRecord generates instance methods based on both names of the columns in the database and the various association macros. There are other methods that can be called on the results of these methods such as `characters.clear`. A list can be found [here](http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html \"Generated Methods\")\r\n\r\n\r\n\r\n###A _Character_ `belongs_to` a _world_\r\nIf a model is a child of another model it gets a `belongs_to` association. If a model has two or more parents it can belong to all of them through multiple `belongs_to` method calls. Another way of looking at the `belongs_to` association is to ask youself if you want this kind of method: `child.dad => #<Dad...>` or `child.mom => #<Mom...>`\r\n\r\nIf a model is a child of anything, it requires a parent_id column to be added to it's corresponding table. Any column with a `_id` suffix becomes a foreign key that points to the corresponding table's id column. So, if a character is a child of world, it will need a world_id column to point to the `worlds` table `id` column.\r\n\r\nHere is our Character model.\r\n```ruby\r\nclass Character < ActiveRecord::Base\r\n  belongs_to :world\r\nend\r\n```\r\n```ruby\r\nclass CreateCharactersTable < ActiveRecord::Migration\r\n  def change\r\n    create_table :characters do |t|\r\n      t.string :name\r\n      t.integer :world_id\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nHere is a nameless character.\r\n```ruby\r\n>> the_character = Character.new\r\n=> #<Character id: nil, name: nil, world_id: nil>\r\n>> character_methods = the_character.methods.map {|method| method.to_s}.sort!\r\n>> (character_methods - control_methods).each {|m| puts m}\r\n```\r\n#####Generated `belongs_to` methods\r\nFrom `belongs_to(:world)` | From DB column :name| Class Methods\r\n--- | --- | ---\r\nworld | name | **none**\r\nworld= | name= | \r\nautosave_associated_records_for_world | name? | \r\nbelongs_to_counter_cache_after_update | name_before_type_cast | \r\nbuild_world | name_came_from_user? | \r\ncreate_world | name_change | \r\ncreate_world! | name_changed? | \r\n | name_was | \r\n | name_will_change! | \r\n | reset_name! | \r\n | restore_name! | \r\n\r\n###A _Character_ `has_many` _power_ups_ `through:` _world_ \r\nAt this point, we've looked at the generated methods we end up with when our class has both a `belongs_to` relationship and a `has_many` relationship. A Character model with both of those relationships would have both sets of methods, along with the database-column generated methods. But what about this `has_many through:` association, that we've got going on between our Characters and their many powerups? Do we get any additional methods showing up? The answer to that question is simply this: no.\r\n\r\n###It's-a Me....\r\nI've gone ahead and created the world `mushroom_kingdom` with a name of \"Mushroom Kingdom\". I've also created two characters named Mario and Luigi along with two powerups: `mushroom`, and `fire_flower`.\r\n\r\nAs stated at the beginning, these are the associations we are after:\r\n```ruby\r\nmushroom_kingdom.characters =>[...]\r\nmushroom_kingdom.power_ups => [...]\r\nmario.world => #<World ...>\r\nfire_flower.world => #<World ...>\r\nmario.power_ups => [...]\r\nfire_flower.characters => [...]\r\n```\r\nHere are updated versions of each of our three classes.\r\n```ruby\r\nclass World < ActiveRecord::Base\r\n  has_many :characters\r\n  has_many :power_ups\r\nend\r\n```\r\n```ruby\r\nclass Character < ActiveRecord::Base\r\n  belongs_to :world\r\n  has_many :power_ups, through: :world\r\nend\r\n```\r\n```ruby\r\nclass PowerUp < ActiveRecord::Base\r\n  belongs_to :world\r\n  belongs_to :character\r\nend\r\n```\r\nAnd here is our current database schema.\r\nNote: The name of the `power_ups` table has an underscore where the class name had an uppercase letter.\r\n```ruby\r\nActiveRecord::Schema.define(version: 20160406024221) do\r\n\r\n  create_table \"characters\", force: :cascade do |t|\r\n    t.string  \"name\"\r\n    t.integer \"world_id\"\r\n  end\r\n\r\n  create_table \"power_ups\", force: :cascade do |t|\r\n    t.string  \"name\"\r\n    t.integer \"world_id\"\r\n  end\r\n\r\n  create_table \"worlds\", force: :cascade do |t|\r\n    t.string \"name\"\r\n    t.integer \"charcter_id\"\r\n    t.integer \"power_ups_id\"    \r\n  end\r\n\r\nend\r\n```\r\nSo lets test some of our methods. \r\nIf we give Mario a world to live in, like this:\r\n```ruby\r\nmario.world = mushroom_kingdom\r\n```\r\nWe expect our `mushroom_kingdom.characters` to return some info about its single inhabitant, Mario.\r\nInstead, however, we get this:\r\n```ruby\r\n>> mushroom_kingdom.characters.first\r\n=> nil\r\n```\r\nHmmm...\r\n<hr>\r\nThe problem is this: \r\n**Children are not responsible**.\r\n<hr>\r\nRather than telling a child object (`mario`) something the parent needs to know, we need to tell the parent (`mushroom_kingdom`). The parent is the responsible one in the relationship and will let the child object know what it needs to know.\r\n```ruby\r\n>> goomba = Character.create(name: \"Goomba\")\r\n=> #<Character id: 3, name: \"Goomba\", world_id: nil>\r\n\r\n>> mushroom_kingdom.characters << goomba\r\n>> goomba.world\r\n=> #<World id: 1, name: \"Mushroom Kingdom\">\r\n\r\n>> goomba\r\n=> #<Character id: 3, name: \"Goomba\", world_id: 1>\r\n\r\n>> mushroom_kingdom.power_ups << mushroom\r\n>> mushroom_kingdom.power_ups << fire_flower\r\n>> fire_flower.world\r\n=> #<World id: 1, name: \"Mushroom Kingdom\">\r\n```\r\n\r\nSo our associations are starting to come together - as long as we are giving our information to the parent and not the irresponsible child. So how about the `has_many through:` association between our characters and our powerups?\r\n```ruby\r\n>> mario.power_ups.first.name\r\n=> \"Mushroom\"\r\n```\r\nSeems to work. The key to making this `has_many through:` association work is in the database. If you look at the `worlds` table above, you'll notice that it has foreign keys (`_id` columns) for both the `characters` table and the `power_ups` table. This is what ties our characters to our powerups. As a general rule, **the `through:` table gets foreign keys for current model and its child**. So what about asking our fire flower which characters have access to it?\r\n```ruby\r\n>>fire_flower.characters.first.name\r\n=> NoMethodError: undefined method `characters' for #<PowerUp id: 2, name: \"Fire Flower\", world_id: 1>\r\n```\r\nIf we look back to our generated methods, we see that it is the `has_many` macro that gives us our `______s` method. Our PowerUp class, however, is using the `belongs_to` macro which does not generate such a method.\r\n<hr>\r\n_When we ask the powerup for a list of characters that own it, it may seems as it `belongs_to` specific characters. However, given the `characters` method that we want, we should view the powerup as though it `has_many` owners._\r\n<hr>\r\n```ruby\r\nclass PowerUp < ActiveRecord::Base\r\n  belongs_to :world\r\n  has_many :characters, through: :world\r\nend\r\n```\r\nOur `world` table is already setup with the proper foreign keys.\r\n```ruby\r\nfire_flower.characters.first.name\r\n=> \"Mario\"\r\n```\r\nThe relationship that characters have with powerups would be called a _many to many_ relationship, as a character can have many powerups, and a powerup can have many owning characters.\r\n\r\n###Many to Many\r\nYou can also set up this kind of association by using the `has_and_belongs_to_many` macro.\r\nTo experiment with this, we'll use a `Game` model to interact with our characters. Our desired behaviour looks like this:\r\n```ruby\r\nmario.games => [...]\r\nsuper_mario_bros.characters => [...]\r\n```\r\nOur classes will need the new macro.\r\n```ruby\r\nclass Game < ActiveRecord::Base\r\n  has_and_belongs_to_many :characters\r\nend\r\n\r\nclass Character < ActiveRecord::Base\r\n  belongs_to :world\r\n  has_many :power_ups, through: :world\r\n  has_and_belongs_to_many :games\r\nend\r\n```\r\nAdditionally, we need a special table in our database called a _join table_. This is a table that only has two foreign keys: one for each of our models.\r\n\r\nWe'll create that, and a table for our `Game` class in two seperate migrations.\r\n```ruby\r\nclass CreateGamesTable < ActiveRecord::Migration\r\n  def change\r\n    create_table :games do |t|\r\n      t.string :name\r\n    end\r\n  end\r\nend\r\n```\r\n```ruby\r\nclass CreateCharacterGameTable < ActiveRecord::Migration\r\n  def change\r\n    create_table :characters_games do |t|\r\n      t.integer :character_id\r\n      t.integer :game_id\r\n    end\r\n  end\r\nend\r\n```\r\nAfter migration, our schema now looks like this:\r\n```ruby\r\nActiveRecord::Schema.define(version: 20160407042123) do\r\n\r\n  create_table \"characters\", force: :cascade do |t|\r\n    t.string  \"name\"\r\n    t.integer \"world_id\"\r\n  end\r\n\r\n  create_table \"characters_games\", force: :cascade do |t|\r\n    t.integer \"character_id\"\r\n    t.integer \"game_id\"\r\n  end\r\n\r\n  create_table \"games\", force: :cascade do |t|\r\n    t.string \"name\"\r\n  end\r\n\r\n  create_table \"power_ups\", force: :cascade do |t|\r\n    t.string  \"name\"\r\n    t.integer \"world_id\"\r\n  end\r\n\r\n  create_table \"worlds\", force: :cascade do |t|\r\n    t.string  \"name\"\r\n    t.integer \"charcter_id\"\r\n    t.integer \"power_ups_id\"\r\n  end\r\n\r\nend\r\n```\r\nAfter creating two games named \"Super Mario Bros\" and \"Super Mario Bros 3\" you can do this:\r\n```ruby\r\nmario.games << super_mario_bros\r\nluigi.games << super_mario_bros\r\n\r\nsuper_mario_bros.characters.first.name\r\n=> \"Mario\"\r\nsuper_mario_bros.characters.last.name\r\n=> \"Luigi\"\r\n\r\nsuper_mario_bros_3.characters << mario\r\nmario.games.first.name\r\n=> \"Super Mario Bros\"\r\nmario.games.last.name\r\n=> \"Super Mario Bros 3\"\r\n```\r\n\r\nClosing Notes:\r\nWhile writing this, I am using Sinatra and tux to interact with both Active Record and the database. One very confusing issue that came up for me with this last section was a seeming failure of the 'many to many' relationship to actually operate both ways. \r\n\r\nFor example, When running the final command `mario.games.last.name`, I would get `\"Super Mario Bros\"` instead of `\"Super Mario Bros 3\"`. I noticed that tux was not querying the database as it did with the `mario.games.first.name` command. Instead, it seemed to simply be pulling from the established local environment where `mario.games`, having already been queried from the database once, had only one game. Upon exiting tux, re-entering, re-establishing our 'mario' variables, and running the command `mario.games.last.name`, the database was queried and now had two games, the last of which was \"Super Mario Bros 3\".\r\n\r\n###Final Thoughts\r\n\r\nIn summing everything up from the above experiment a few simple rules emerge. Follow these, and you will arrive at Active Record Association bliss.\r\n\r\n#####Rules to Live By\r\n - A Parent `has_many`,  a Child `belongs_to`\r\n - Give the child table the foreign key (`_id`) columns.\r\n - Provide the parent with information, not the child.\r\n - When using a `has_many through` association, the `through` table requires the foreign keys for parent and child.\r\n - When using a `has_and_belongs_to_many` association an additional join table is required.\r\n  - This table should be named with the plural versions of both tables, joined by an underscore, and in alphabetical order.\r\n  - It's best to remove the primary `id` key. `:id => false`\r\n  - Its two columns are simple foreign keys.\r\n - Lastly, ask yourself what method/result you want. Refer to the above charts to help you determine which association will give you that method/result.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}